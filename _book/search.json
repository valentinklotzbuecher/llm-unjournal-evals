[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Comparing LLM and human reviews of social science research using data from Unjournal.org",
    "section": "",
    "text": "Introduction\nInclude global setup and parameters\nsource(\"setup_params.R\")\nIs AI good at peer-reviewing? Does it offer useful and valid feedback? Can it predict how human experts will rate research across a range of categories? How can it help academics do this “thankless” task better? Is it particularly good at spotting errors? Are there specific categories, e.g. spotting math errors or judging real-world relevance, where it does surprisingly well or poorly? How does its “research taste” compare to humans?\nIf AI research-evaluation works it could free up a lot of scientific resources – perhaps $1.5 billion/year in the US alone Aczel, Szaszi, and Holcombe (2021)) – and offer more continual and detailed review, helping improve research. It could also help characterize methodological strengths/weaknesses across papers, aiding training and research direction-setting. Furthermore, a key promise of AI is to directly improve science and research. Understanding how AI engages with research evaluations may provide a window into its values, abilities, and limitations.\nIn this project, we are testing the capabilities of current large language models (LLMs), illustrating whether they can generate research paper evaluations comparable to expert human reviews. The Unjournal systematically prioritizes ‘impactful’ research and pays for high-quality human evaluations, structured quantified ratings, claim identification and assessment, and predictions. In this project, we use an AI (OpenAI’s GPT-5 Pro model) to review social science research papers under the same criteria used by human reviewers for The Unjournal.\nEach paper is assessed on specific dimensions – for example, the strength of its evidence, rigor of methods, clarity of communication, openness/reproducibility, relevance to global priorities, and overall quality. The LLM will provide quantitative scores (with uncertainty intervals) on these criteria and produce a written evaluation\nOur initial dataset will include the 5 research papers that have existing Unjournal human evaluations. For each paper, the AI will generate: (1) numeric ratings on the defined criteria, (2) identification of the paper’s key claims, and (3) a detailed review discussing the paper’s contributions and weaknesses. We will then compare the AI-generated evaluations to the published human evaluations.\nIn the next phase, we will focus on papers currently under evaluation, i.e., where no human evaluation has been made public, to allow us to rule out any contamination.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Comparing LLM and human reviews of social science research using data from Unjournal.org",
    "section": "",
    "text": "Other work has relied on collections of research and grant reviews, including NLPEER, SubstanReview, and the Swiss National Science Foundation. That data has a heavy focus on computer-science adjacent fields, and iss less representative of mainstream research peer review practices in older, established academic fields. Note that The Unjournal commissions the evaluation of impactful research, often from high-prestige working paper archives like NBER, and makes all evaluations public, even if they are highly critical of the paper.↩︎\nAbout verifiable publication outcomes, not about the ‘true quality’ of the paper of course.↩︎\nOur approach differs from prior work by (i) focusing on structured, percentile-based quantitative ratings with credible intervals that map to decision-relevant dimensions used by The Unjournal; (ii) comparing those ratings to published human evaluations rather than using LLM-as-judge; and (iii) curating contamination-aware inputs (paper text extraction with reference-section removal and token caps), with a roadmap to add multi-modal checks when we score figure- or table-dependent criteria.↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "methods.html",
    "href": "methods.html",
    "title": "Data and methods",
    "section": "",
    "text": "Unjournal.org evaluations\nWe use The Unjournal’s public data for a baseline comparison. At The Unjournal each paper is typically evaluated (aka ‘reviewed’) by two expert evaluators1 who provide quantitative ratings on a 0–100 percentile scale for each of seven criteria (with 90% credible intervals),2 two “journal tier” ratings on a 0.0 - 5.0 scale,3 a written evaluation (resembling a referee report for a journal), and identification and assessment of the paper’s “main claim”. For our initial analysis, we extracted these human ratings and aggregated them, taking the average score per criterion across evaluators (and noting the range of individual scores).\nAll papers have completed The Unjournal’s evaluation process (meaning the authors received a full evaluation on the Unjournal platform, which has been publicly posted at unjournal.pubpub.org). The sample includes papers spanning 2017–2025 working papers in development economics, growth, health policy, environmental economics, and related fields that The Unjournal identified as high-impact. Each of these papers has quantitative scores from at least one human evaluator, and many have multiple (2-3) human ratings.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data and methods</span>"
    ]
  },
  {
    "objectID": "methods.html#llm-based-evaluation",
    "href": "methods.html#llm-based-evaluation",
    "title": "Data and methods",
    "section": "LLM-based evaluation",
    "text": "LLM-based evaluation\n\nQuantitative ratings and journal-ranking tiers\nFollowing The Unjournal’s standard guidelines for evaluators and their academic evaluation form, evaluators are asked to consider each paper along the following dimensions: claims & evidence, methods, logic & communication, open science, global relevance, and an overall assessment. Ratings are interpreted as percentiles relative to serious recent work in the same area. For each metric, evaluators are asked for the midpoint of their beliefs and their 90% credible interval, to communicate their uncertainty. For the journal rankings measure, we ask both “what journal ranking tier should this work be published in? (0.0-5.0)” and “what journal ranking tier will this work be published in? (0.0-5.0)”, with some further explanation.The full prompt can be seen in the code below – essentially copied from the Unjournal’s guidelines page.\n\nWe captured the versions of each paper that was evaluated by The Unjournal’s human evaluators, downloading from the links provided in The Unjournal’s Coda database. \nWe evaluate each paper by passing the PDF directly to the model and requiring a strict, machine‑readable JSON output. This keeps the assessment tied to the document the authors wrote. Direct ingestion preserves tables, figures, equations, and sectioning, which ad‑hoc text scraping can mangle. It also avoids silent trimming or segmentation choices that would bias what the model sees.\n\n\nLLM evaluation pipeline setup\nimport os, time, json, random, hashlib\nimport pathlib\nfrom typing import Any, Dict, Optional, Union\n\nimport pandas as pd\nimport numpy as np\n\nimport openai\nfrom openai import OpenAI\n\n# ---------- Configuration (in-file, no external deps)\nAPI_KEY_PATH = pathlib.Path(os.getenv(\"OPENAI_KEY_PATH\", \"key/openai_key.txt\"))\nMODEL        = os.getenv(\"OPENAI_MODEL\", \"gpt-5-pro\")\nFILE_PURPOSE = \"assistants\"  # for Responses API file inputs\nRESULTS_DIR  = pathlib.Path(\"results\")\nRESULTS_DIR.mkdir(exist_ok=True)\nFILE_CACHE   = RESULTS_DIR / \".file_cache.json\"\n\n# ---------- API key bootstrap\nif os.getenv(\"OPENAI_API_KEY\") is None and API_KEY_PATH.exists():\n    os.environ[\"OPENAI_API_KEY\"] = API_KEY_PATH.read_text().strip()\nif not os.getenv(\"OPENAI_API_KEY\"):\n    raise ValueError(\"No API key. Set OPENAI_API_KEY or create key/openai_key.txt\")\n\nclient = OpenAI()\n\n# ---------- Small utilities (inlined replacements for llm_utils)\n\ndef _resp_as_dict(resp: Any) -&gt; Dict[str, Any]:\n    if isinstance(resp, dict):\n        return resp\n    for attr in (\"to_dict\", \"model_dump\", \"dict\", \"json\"):\n        if hasattr(resp, attr):\n            try:\n                val = getattr(resp, attr)()\n                if isinstance(val, (str, bytes)):\n                    try:\n                        return json.loads(val)\n                    except Exception:\n                        pass\n                if isinstance(val, dict):\n                    return val\n            except Exception:\n                pass\n    # last resort\n    try:\n        return json.loads(str(resp))\n    except Exception:\n        return {\"_raw\": str(resp)}\n\ndef _get_output_text(resp: Any) -&gt; str:\n    d = _resp_as_dict(resp)\n    if \"output_text\" in d and isinstance(d[\"output_text\"], str):\n        return d[\"output_text\"]\n    out = d.get(\"output\") or []\n    chunks = []\n    for item in out:\n        if not isinstance(item, dict): continue\n        if item.get(\"type\") == \"message\":\n            for c in item.get(\"content\") or []:\n                if isinstance(c, dict):\n                    if \"text\" in c and isinstance(c[\"text\"], str):\n                        chunks.append(c[\"text\"])\n                    elif \"output_text\" in c and isinstance(c[\"output_text\"], str):\n                        chunks.append(c[\"output_text\"])\n    # Also check legacy top-level choices-like structures\n    if not chunks:\n        for k in (\"content\", \"message\"):\n            v = d.get(k)\n            if isinstance(v, str):\n                chunks.append(v)\n    return \"\\n\".join(chunks).strip()\n\ndef _extract_json(s: str) -&gt; Dict[str, Any]:\n    \"\"\"Robustly extract first top-level JSON object from a string.\"\"\"\n    if not s:\n        raise ValueError(\"empty output text\")\n    # Fast path\n    s_stripped = s.strip()\n    if s_stripped.startswith(\"{\") and s_stripped.endswith(\"}\"):\n        return json.loads(s_stripped)\n\n    # Find first balanced {...} while respecting strings\n    start = s.find(\"{\")\n    if start == -1:\n        raise ValueError(\"no JSON object start found\")\n    i = start\n    depth = 0\n    in_str = False\n    esc = False\n    for i in range(start, len(s)):\n        ch = s[i]\n        if in_str:\n            if esc:\n                esc = False\n            elif ch == \"\\\\\":\n                esc = True\n            elif ch == '\"':\n                in_str = False\n        else:\n            if ch == '\"':\n                in_str = True\n            elif ch == \"{\":\n                depth += 1\n            elif ch == \"}\":\n                depth -= 1\n                if depth == 0:\n                    candidate = s[start:i+1]\n                    return json.loads(candidate)\n    raise ValueError(\"no balanced JSON object found\")\n\ndef call_with_retries(fn, max_tries: int = 6, base_delay: float = 0.8, max_delay: float = 8.0):\n    ex = None\n    for attempt in range(1, max_tries + 1):\n        try:\n            return fn()\n        except (openai.RateLimitError, openai.APIError, openai.APIConnectionError, openai.APITimeoutError, Exception) as e:\n            ex = e\n            sleep = min(max_delay, base_delay * (1.8 ** (attempt - 1))) * (1 + 0.25 * random.random())\n            time.sleep(sleep)\n    raise ex\n\ndef _load_cache() -&gt; Dict[str, Any]:\n    if FILE_CACHE.exists():\n        try:\n            return json.loads(FILE_CACHE.read_text())\n        except Exception:\n            return {}\n    return {}\n\ndef _save_cache(cache: Dict[str, Any]) -&gt; None:\n    FILE_CACHE.write_text(json.dumps(cache, ensure_ascii=False, indent=2))\n\ndef _file_sig(p: pathlib.Path) -&gt; Dict[str, Any]:\n    st = p.stat()\n    return {\"size\": st.st_size, \"mtime\": int(st.st_mtime)}\n\ndef get_file_id(path: Union[str, pathlib.Path], client: OpenAI) -&gt; str:\n    p = pathlib.Path(path)\n    if not p.exists():\n        raise FileNotFoundError(p)\n    cache = _load_cache()\n    key = str(p.resolve())\n    sig = _file_sig(p)\n    meta = cache.get(key)\n    if meta and meta.get(\"size\") == sig[\"size\"] and meta.get(\"mtime\") == sig[\"mtime\"] and meta.get(\"file_id\"):\n        return meta[\"file_id\"]\n    # Upload fresh\n    with open(p, \"rb\") as fh:\n      f = call_with_retries(lambda: client.files.create(file=fh, purpose=FILE_PURPOSE))\n    fd = _resp_as_dict(f)\n    fid = fd.get(\"id\")\n    if not fid:\n        raise RuntimeError(f\"Upload did not return file id: {fd}\")\n    cache[key] = {\"file_id\": fid, **sig}\n    _save_cache(cache)\n    return fid\n\ndef _reasoning_meta(resp) -&gt; Dict[str, Any]:\n    d = _resp_as_dict(resp)\n    rid, summary_text = None, None\n    out = d.get(\"output\") or []\n    if out and isinstance(out, list) and out[0].get(\"type\") == \"reasoning\":\n        rid = out[0].get(\"id\")\n        summ = out[0].get(\"summary\") or []\n        if summ and isinstance(summ, list):\n            summary_text = summ[0].get(\"text\")\n    usage = d.get(\"usage\") or {}\n    odet  = usage.get(\"output_tokens_details\") or {}\n    return {\n        \"response_id\": d.get(\"id\"),\n        \"reasoning_id\": rid,\n        \"reasoning_summary\": summary_text,\n        \"input_tokens\": usage.get(\"input_tokens\"),\n        \"output_tokens\": usage.get(\"output_tokens\"),\n        \"reasoning_tokens\": odet.get(\"reasoning_tokens\"),\n    }\n    \n\ndef read_csv_or_empty(path, columns=None, **kwargs):\n    p = pathlib.Path(path)\n    if not p.exists():\n        return pd.DataFrame(columns=columns or [])\n    try:\n        df = pd.read_csv(p, **kwargs)\n        if df is None or getattr(df, \"shape\", (0,0))[1] == 0:\n            return pd.DataFrame(columns=columns or [])\n        return df\n    except (pd.errors.EmptyDataError, pd.errors.ParserError, OSError, ValueError):\n        return pd.DataFrame(columns=columns or [])    \n\n\nWe enforce a JSON Schema for the results. The model must return one object for each of the named criteria including a midpoint rating and a 90% interval for each rating. This guarantees that every paper is scored on the same fields with the same types and bounds. It makes the analysis reproducible and comparisons clean.\nWe request credible intervals (as we do for human evaluators) to allow the model to communicate its uncertainty rather than suggest false precision; these can also be incorporated into our metrics, penalizing a model’s inaccuracy more when it’s stated with high confidence.\n\n\nSchema, prompt, evaluator\n# --- Metrics and schema\nMETRICS = [\n    \"overall\",\n    \"claims_evidence\",\n    \"methods\",\n    \"advancing_knowledge\",\n    \"logic_communication\",\n    \"open_science\",\n    \"global_relevance\",\n]\n\nmetric_schema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"midpoint\":    {\"type\": \"number\", \"minimum\": 0, \"maximum\": 100},\n        \"lower_bound\": {\"type\": \"number\", \"minimum\": 0, \"maximum\": 100},\n        \"upper_bound\": {\"type\": \"number\", \"minimum\": 0, \"maximum\": 100},\n    },\n    \"required\": [\"midpoint\", \"lower_bound\", \"upper_bound\"],\n    \"additionalProperties\": False,\n}\n\nTIER_METRIC_SCHEMA = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"score\":   {\"type\": \"number\", \"minimum\": 0, \"maximum\": 5},\n        \"ci_lower\":{\"type\": \"number\", \"minimum\": 0, \"maximum\": 5},\n        \"ci_upper\":{\"type\": \"number\", \"minimum\": 0, \"maximum\": 5},\n    },\n    \"required\": [\"score\", \"ci_lower\", \"ci_upper\"],\n    \"additionalProperties\": False,\n}\n\nCOMBINED_SCHEMA = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"assessment_summary\": {\"type\": \"string\",\"maxLength\": 5000},\n        \"metrics\": {\n            \"type\": \"object\",\n            \"properties\": {\n                **{m: metric_schema for m in METRICS},\n                \"tier_should\": TIER_METRIC_SCHEMA,\n                \"tier_will\":   TIER_METRIC_SCHEMA,\n            },\n            \"required\": METRICS + [\"tier_should\", \"tier_will\"],\n            \"additionalProperties\": False,\n        },\n    },\n    \"required\": [\"assessment_summary\", \"metrics\"],\n    \"additionalProperties\": False,\n}\n\nTEXT_FORMAT_COMBINED = {\n    \"type\": \"json_schema\",\n    \"name\": \"paper_assessment_with_tiers_v2\",\n    \"strict\": True,\n    \"schema\": COMBINED_SCHEMA,\n}\n\n#Todo -- adjust the 'diagnostic summary' below to take into account more aspects of our criteria\n\nSYSTEM_PROMPT_COMBINED = f\"\"\"\n\nYour role -- You are an academic expert as well as a practitioner across every relevant field -- use all your knowledge and insight. You are acting as an expert research evaluator/reviewer. \nDo not look at any existing ratings or evaluations of these papers you might find on the internet or in your corpus, do not use the authors' names, status, or institutions in your judgment -- give your assessment based on the *content* of the papers alone; do it based on your knowledge and insights. \n\nDiagnostic summary (Aim for about 1000 words, based only on the PDF):\nProvide a compact paragraph that identifies the most important issues you detect in the manuscript itself (e.g., identification threats, data limitations, misinterpretations, internal inconsistencies, missing robustness, replication barriers). Be specific, neutral, and concrete. This summary should precede any scoring and should guide your uncertainty. Output this text in the JSON field `assessment_summary`.\n\nWe ask for a set of quantitative metrics, based on your insights. For each metric, we ask for a score and a 90% credible interval. We describe these in detail below.\n\nPercentile rankings relative to a reference group: For some questions, we ask for a percentile ranking from 0-100%. This represents \"what proportion of papers in the reference group are worse than this paper, by this criterion\". A score of 100% means this is essentially the best paper in the reference group. 0% is the worst paper. A score of 50% means this is the median paper; i.e., half of all papers in the reference group do this better, and half do this worse, and so on. Here the population of papers should be all serious research in the same area that you have encountered in the last three years.  *Unless this work is in our 'applied and policy stream', in which case the reference group should be \"all applied and policy research you have read that is aiming at a similar audience, and that has similar goals\".\n\n\"Serious\" research? Academic research? \nHere, we are mainly considering research done by professional researchers with high levels of training, experience, and familiarity with recent practice, who have time and resources to devote months or years to each such research project or paper. \nThese will typically be written as 'working papers' and presented at academic seminars before being submitted to standard academic journals. Although no credential is required, this typically includes people with PhD degrees (or upper-level PhD students). Most of this sort of research is done by full-time academics (professors, post-docs, academic staff, etc.) with a substantial research remit, as well as research staff at think tanks and research institutions (but there may be important exceptions).\n\nWhat counts as the \"same area\"?\nThis is a judgment call. Some criteria to consider... First, does the work come from the same academic field and research subfield, and does it address questions that might be addressed using similar methods? Second, does it deal with the same substantive research question, or a closely related one? If the research you are evaluating is in a very niche topic, the comparison reference group should be expanded to consider work in other areas.\n\n\"Research that you have encountered\"\nWe are aiming for comparability across evaluators. If you suspect you are particularly exposed to higher-quality work in this category, compared to other likely evaluators, you may want to adjust your reference group downwards. (And of course vice-versa, if you suspect you are particularly exposed to lower-quality work.)\n\nMidpoint rating and credible intervals: For each metric, we ask you to provide a 'midpoint rating' and a 90% credible interval as a measure of your uncertainty.\n\n    - \"overall\" - Overall assessment - Percentile ranking (0-100%): Judge the quality of the research heuristically. Consider all aspects of quality, credibility, importance to future impactful applied research, and practical relevance and usefulness, importance to knowledge production, and importance to practice.\n\n    - \"claims_evidence\" - Claims, strength and characterization of evidence (0-100%): Do the authors do a good job of (i) stating their main questions and claims, (ii) providing strong evidence and powerful approaches to inform these, and (iii) correctly characterizing the nature of their evidence?\n\n    - \"methods\" - Justification, reasonableness, validity, robustness (0-100%): Are the methods[^7] used well-justified and explained; are they a reasonable approach to answering the question(s) in this context? Are the underlying assumptions reasonable? Are the results and methods likely to be robust to reasonable changes in the underlying assumptions? Does the author demonstrate this? Did the authors take steps to reduce bias from opportunistic reporting and questionable research practices?\n\n    - \"advancing_knowledge\" - Advancing our knowledge and practice (0-100%): To what extent does the project contribute to the field or to practice, particularly in ways that are relevant[^10] to global priorities and impactful interventions? (Applied stream: please focus on ‘improvements that are actually helpful’.) Less weight to \"originality and cleverness’: Originality and cleverness should be weighted less than the typical journal, because we focus on impact. Papers that apply existing techniques and frameworks more rigorously than previous work or apply them to new areas in ways that provide practical insights for GP (global priorities) and interventions should be highly valued. More weight should be placed on 'contribution to GP' than on 'contribution to the academic field'.\n            Do the paper's insights inform our beliefs about important parameters and about the effectiveness of interventions?\n            Does the project add useful value to other impactful research?\n            We don't require surprising results; sound and well-presented null results can also be valuable.\n\n    - \"logic_communication\" - \"Logic and communication (0-100%): Are the goals and questions of the paper clearly expressed? Are concepts clearly defined and referenced? Is the reasoning \"transparent\"? Are assumptions made explicit? Are all logical steps clear and correct? Does the writing make the argument easy to follow? Are the conclusions consistent with the evidence (or formal proofs) presented? Do the authors accurately state the nature of their evidence, and the extent it supports their main claims? Are the data and/or analysis presented relevant to the arguments made? Are the tables, graphs, and diagrams easy to understand in the context of the narrative (e.g., no major errors in labeling)?\n\n    - \"open_science\" - Open, collaborative, replicable research (0-100%): This covers several considerations: \n        - Replicability, reproducibility, data integrity: Would another researcher be able to perform the same analysis and get the same results? Are the methods explained clearly and in enough detail to enable easy and credible replication? For example, are all analyses and statistical tests explained, and is code provided? Is the source of the data clear? Is the data made as available as is reasonably possible? If so, is it clearly labeled and explained??\n        - Consistency: Do the numbers in the paper and/or code output make sense? Are they internally consistent throughout the paper?  \n        - Useful building blocks: Do the authors provide tools, resources, data, and outputs that might enable or enhance future work and meta-analysis?\n\n    - \"global_relevance\" - Relevance to global priorities, usefulness for practitioners: Are the paper’s chosen topic and approach likely to be useful to global priorities, cause prioritization, and high-impact interventions? Does the paper consider real-world relevance and deal with policy and implementation questions? Are the setup, assumptions, and focus realistic? Do the authors report results that are relevant to practitioners? Do they provide useful quantified estimates (costs, benefits, etc.) enabling practical impact quantification and prioritization? Do they communicate (at least in the abstract or introduction)  in ways policymakers and decision-makers can understand, without misleading or oversimplifying?\n\n\nThe midpoint and 'credible intervals': expressing uncertainty - What are we looking for and why? \n    - We want policymakers, researchers, funders, and managers to be able to use The Unjournal'&#x73; evaluations to update their beliefs and make better decisions. To do this well, they need to weigh multiple evaluations against each other and other sources of information. Evaluators may feel confident about their rating for one category, but less confident in another area. How much weight should readers give to each? In this context, it is useful to quantify the uncertainty. But it's hard to quantify statements like \"very certain\" or \"somewhat uncertain\" – different people may use the same phrases to mean different things. That's why we're asking for you a more precise measure, your credible intervals. These metrics are particularly useful for meta-science and meta-analysis. You are asked to give a 'midpoint' and a 90% credible interval. Consider this as the smallest interval that you believe is 90% likely to contain the true value.\n    - How do I come up with these intervals? (Discussion and guidance): You may understand the concepts of uncertainty and credible intervals, but you might be unfamiliar with applying them in a situation like this one. You may have a certain best guess for the \"Methods...\" criterion. Still, even an expert can never be certain. E.g., you may misunderstand some aspect of the paper, there may be a method you are not familiar with, etc. Your uncertainty over this could be described by some distribution, representing your beliefs about the true value of this criterion. Your \"'best guess\" should be the central mass point of this distribution. For some questions, the \"true value\" refers to something objective, e.g. will this work be published in a top-ranked journal? In other cases, like the percentile rankings, the true value means \"if you had complete evidence, knowledge, and wisdom, what value would you choose?\" If you are well calibrated your 90% credible intervals should contain the true value 90% of the time. Consider the midpoint as the 'median of your belief distribution'\n    - We also ask for the 'midpoint', the center dot on that slider. Essentially, we are asking for the median of your belief distribution. By this we mean the percentile ranking such that you believe \"there's a 50% chance that  the paper's true rank is higher than this, and a 50% chance that it actually ranks lower than this.\"\n\n\nAdditionally, we ask: What journal ranking tier should and will this work be published in?\n\nTo help universities and policymakers make sense of our evaluations, we want to benchmark them against how research is currently judged. So, we would like you to assess the paper in terms of journal rankings. We ask for two assessments:\n\n    1. a normative judgment about 'how well the research should publish';\n    2. a prediction about where the research will be published.\n    As before, we ask for a 90% credible interval.\n\n    Journal ranking tiers are on a 0-5 scale, as follows:\n        0/5: \"Won't publish/little to no value\".  Unlikely to be cited by credible researchers\n        1/5: OK/Somewhat valuable journal\n        2/5: Marginal B-journal/Decent field journal\n        3/5: Top B-journal/Strong field journal\n        4/5: Marginal A-Journal/Top field journal\n        5/5: A-journal/Top journal\n\n    - We encourage you to consider a non-integer score, e.g. 4.6 or 2.2. If a paper/project would be most likely to be (or merits being) published in a journal that would rank about halfway between a top tier 'A journal' and a second tier (4/5) journal, you should rate it a 4.5. Similarly, if you think it has an 80%  chance of (being/meriting) publication in a 'marginal B-journal' and a 20% chance of a Top B-journal, you should rate it 2.2. Please also use this continuous scale for providing credible intervals. If a paper/project would be most likely to be (or merits being) published in a journal that would rank about halfway between a top tier 'A journal' and a second tier (4/5) journal, you should rate it a 4.5.\n\n    - Journal ranking tier \"should\" (0.0-5.0)\n        Schema: tiershould: Assess this paper on the journal ranking scale described above, considering only its merit, giving some weight to the category metrics we discussed above. Equivalently, where would this paper be published if: \n        1. the journal process was fair, unbiased, and free of noise, and that status, social connections, and lobbying to get the paper published didn’t matter;\n        2. journals assessed research according to the category metrics we discussed above.\n\n    - Journal ranking tier \"will\" (0.0-5.0) \n        Schema: tierwill: What if this work has already been peer reviewed and published? If this work has already been published, and you know where, please report the prediction you would have given absent that knowledge.\n\nReturn STRICT JSON matching the supplied schema. No preamble. No markdown. No extra text.\n\nFill both top-level keys:\n- `assessment_summary`: about 1000 words.\n- `metrics`: object containing all required metrics.\n\nField names\n- Percentile metrics → `midpoint`, `lower_bound`, `upper_bound`.\n- Tier metrics → `score`, `ci_lower`, `ci_upper`.\n\nBounds\n- Percentiles in [0, 100] with lower_bound ≤ midpoint ≤ upper_bound.\n- Tiers in [0, 5] with ci_lower ≤ score ≤ ci_upper.\n\nDo not include citations, URLs, author identity, or any external information.\n Percentiles in [0, 100] with lower_bound ≤ midpoint ≤ upper_bound.\n- Tiers in [0, 5] with ci_lower ≤ score ≤ ci_upper.\n\nDo not include citations, URLs, author identity, or any external information.\n\"\"\".strip()\n\n# Async-by-default kickoff: submit and return job metadata. No waiting.\ndef evaluate_paper(pdf_path: Union[str, pathlib.Path],\n                   model: Optional[str] = None,\n                   use_reasoning: bool = True) -&gt; Dict[str, Any]:\n    model = model or MODEL\n    fid = get_file_id(pdf_path, client)\n\n    def _payload():\n        p = dict(\n            model=model,\n            text={\"format\": TEXT_FORMAT_COMBINED, \"verbosity\": \"high\"},\n            input=[\n                {\"role\": \"system\", \"content\": [\n                    {\"type\": \"input_text\", \"text\": SYSTEM_PROMPT_COMBINED}\n                ]},\n                {\"role\": \"user\", \"content\": [\n                    {\"type\": \"input_file\", \"file_id\": fid},\n                    {\"type\": \"input_text\", \"text\": \"Return STRICT JSON per schema. No extra text.\"}\n                ]},\n            ],\n            max_output_tokens=8000,\n            background=True,\n            store=True,\n        )\n        if use_reasoning:\n            p[\"reasoning\"] = {\"effort\": \"high\", \"summary\": \"auto\"}\n        return p\n\n    kickoff = call_with_retries(lambda: client.responses.create(**_payload()))\n    kd = _resp_as_dict(kickoff)\n    return {\n        \"response_id\": kd.get(\"id\"),\n        \"file_id\": fid,\n        \"status\": kd.get(\"status\") or \"queued\",\n        \"model\": model,\n        \"created_at\": kd.get(\"created_at\"),\n    }\n\n\nRelying on GPT-5 Pro, we use a single‑step call with a reasoning model that supports file input. One step avoids hand‑offs and summary loss from a separate “ingestion” stage. The model reads the whole PDF and produces the JSON defined above. We do not retrieve external sources or cross‑paper material for these scores; the evaluation is anchored in the manuscript itself.\nThe Python pipeline uploads each PDF once and caches the returned file id keyed by path, size, and modification time. We submit one background job per PDF to the OpenAI Responses API with “high” reasoning effort and server‑side JSON‑Schema enforcement. Submissions record the response id, model id, file id, status, and timestamps.\n\n\nKick off background jobs → results/jobs_index.csv\nimport pathlib, time\n\nROOT = pathlib.Path(os.getenv(\"UJ_PAPERS_DIR\", \"papers\")).expanduser()\nOUT  = pathlib.Path(\"results\"); OUT.mkdir(exist_ok=True)\nIDX  = OUT / \"jobs_index.csv\"\n\npdfs = sorted(ROOT.glob(\"*.pdf\"))\nprint(\"Found PDFs:\", [p.name for p in pdfs])\n\ncols = [\"paper\",\"pdf\",\"response_id\",\"file_id\",\"model\",\"status\",\"created_at\",\"last_update\",\"collected\",\"error\"]\nidx = read_csv_or_empty(IDX, columns=cols)\nfor c in cols:\n    if c not in idx.columns: idx[c] = pd.NA\n\nexisting = dict(zip(idx[\"paper\"], idx[\"status\"])) if not idx.empty else {}\nstarted = []\n\nfor pdf in pdfs:\n    paper = pdf.stem\n    if existing.get(paper) in (\"queued\",\"in_progress\",\"incomplete\",\"requires_action\"):\n        print(f\"skip {pdf.name}: job already running\")\n        continue\n    try:\n        job = evaluate_paper(pdf, model=MODEL, use_reasoning=True)\n        started.append({\n            \"paper\": paper,\n            \"pdf\": str(pdf),\n            \"response_id\": job.get(\"response_id\"),\n            \"file_id\": job.get(\"file_id\"),\n            \"model\": job.get(\"model\"),\n            \"status\": job.get(\"status\"),\n            \"created_at\": job.get(\"created_at\") or pd.Timestamp.utcnow().isoformat(),\n            \"last_update\": pd.Timestamp.utcnow().isoformat(),\n            \"collected\": False,\n            \"error\": pd.NA,\n        })\n        print(f\"✓ Started job for {pdf.name}, waiting 90s before next submission...\")\n        time.sleep(90)  # Wait 90s between submissions to avoid TPM rate limits\n    except Exception as e:\n        print(f\"⚠️ kickoff failed for {pdf.name}: {e}\")\n\nif started:\n    idx = pd.concat([idx, pd.DataFrame(started)], ignore_index=True)\n    idx.drop_duplicates(subset=[\"paper\"], keep=\"last\", inplace=True)\n    idx.to_csv(IDX, index=False)\n    print(f\"Started {len(started)} jobs → {IDX}\")\nelse:\n    print(\"No new jobs started.\")\n\n\nA separate script polls job status and, for each completed job, retrieves the raw response, extracts the first balanced top‑level JSON object, and writes both the raw response and parsed outputs to disk.\n\n\nPoll status, collect completed outputs, write per-paper and combined CSVs\nimport json, pathlib, pandas as pd\n\nOUT = pathlib.Path(\"results\")\nIDX = OUT / \"jobs_index.csv\"\nPER = OUT / \"per_paper\"; PER.mkdir(exist_ok=True)\nJSN = OUT / \"json\"; JSN.mkdir(exist_ok=True)\n\ndef _safe_read_csv(path, columns):\n    p = pathlib.Path(path)\n    if not p.exists():\n        return pd.DataFrame(columns=columns)\n    try:\n        # Set dtype='object' for string columns to avoid dtype warnings\n        df = pd.read_csv(p, dtype={'error': 'object', 'reasoning_id': 'object'})\n    except Exception:\n        return pd.DataFrame(columns=columns)\n    for c in columns:\n        if c not in df.columns:\n            df[c] = pd.NA\n    return df\n\ncols = [\"paper\",\"pdf\",\"response_id\",\"file_id\",\"model\",\"status\",\"created_at\",\n        \"last_update\",\"collected\",\"error\",\"reasoning_id\",\"input_tokens\",\n        \"output_tokens\",\"reasoning_tokens\"]\nidx = _safe_read_csv(IDX, cols)\n\nif idx.empty:\n    print(\"Index is empty.\")\nelse:\n    term = {\"completed\",\"failed\",\"cancelled\",\"expired\"}\n    for i, row in idx.iterrows():\n        if str(row.get(\"status\")) in term:\n            continue\n        try:\n            r = client.responses.retrieve(str(row[\"response_id\"]))\n            d = _resp_as_dict(r)\n            idx.at[i,\"status\"] = d.get(\"status\")\n            idx.at[i,\"last_update\"] = pd.Timestamp.utcnow().isoformat()\n            if d.get(\"status\") in term and d.get(\"status\") != \"completed\":\n                idx.at[i,\"error\"] = json.dumps(d.get(\"incomplete_details\") or {})\n        except Exception as e:\n            idx.at[i,\"error\"] = str(e)\n\n    newly_done = idx[(idx[\"status\"]==\"completed\") & (idx[\"collected\"]==False)]\n    print(f\"Completed and pending collection: {len(newly_done)}\")\n\n    rows_accum, summaries = [], []\n    for i, row in newly_done.iterrows():\n        rid   = str(row[\"response_id\"])\n        paper = str(row[\"paper\"])\n        try:\n            r = client.responses.retrieve(rid)\n\n            with open(JSN / f\"{paper}.response.json\", \"w\", encoding=\"utf-8\") as f:\n                f.write(json.dumps(_resp_as_dict(r), ensure_ascii=False))\n\n            jtxt = _get_output_text(r)\n            j    = _extract_json(jtxt)\n\n            for metric, vals in (j.get(\"metrics\") or {}).items():\n                if metric in (\"tier_should\",\"tier_will\"):\n                    rows_accum.append({\n                        \"paper\": paper, \"metric\": metric, \"metric_type\": \"tier\",\n                        \"value\": vals.get(\"score\"), \"lo\": vals.get(\"ci_lower\"), \"hi\": vals.get(\"ci_upper\"),\n                        \"scale_min\": 0, \"scale_max\": 5,\n                    })\n                else:\n                    rows_accum.append({\n                        \"paper\": paper, \"metric\": metric, \"metric_type\": \"percentile\",\n                        \"value\": vals.get(\"midpoint\"), \"lo\": vals.get(\"lower_bound\"), \"hi\": vals.get(\"upper_bound\"),\n                        \"scale_min\": 0, \"scale_max\": 100,\n                    })\n\n            if \"assessment_summary\" in j:\n                summaries.append({\"paper\": paper, \"assessment_summary\": j[\"assessment_summary\"]})\n\n            per_df = pd.DataFrame([r for r in rows_accum if r[\"paper\"]==paper])\n            per_df.to_csv(PER / f\"{paper}_long.csv\", index=False, encoding=\"utf-8\")\n\n            m = _reasoning_meta(r)\n            idx.at[i,\"collected\"] = True\n            idx.at[i,\"error\"] = pd.NA\n            idx.at[i,\"reasoning_id\"] = m.get(\"reasoning_id\")\n            idx.at[i,\"input_tokens\"] = m.get(\"input_tokens\")\n            idx.at[i,\"output_tokens\"] = m.get(\"output_tokens\")\n            idx.at[i,\"reasoning_tokens\"] = m.get(\"reasoning_tokens\")\n\n        except Exception as e:\n            idx.at[i,\"error\"] = f\"collect: {e}\"\n\n    if rows_accum:\n        combined = pd.DataFrame(rows_accum)\n\n        # merge with any previous combined_long.csv\n        comb_path = OUT / \"combined_long.csv\"\n        prev_cols = [\"paper\",\"metric\",\"metric_type\",\"value\",\"lo\",\"hi\",\"scale_min\",\"scale_max\"]\n        prev = _safe_read_csv(comb_path, prev_cols)\n        if not prev.empty:\n            prev = prev[~prev[\"paper\"].isin(newly_done[\"paper\"])]\n            combined = pd.concat([prev, combined], ignore_index=True)\n        combined.to_csv(comb_path, index=False, encoding=\"utf-8\")\n\n        # metrics_long.csv (no leading-dot chaining)\n        metrics_df = combined[combined[\"metric_type\"]==\"percentile\"].copy()\n        metrics_df = metrics_df.rename(columns={\"value\":\"midpoint\",\"lo\":\"lower_bound\",\"hi\":\"upper_bound\"})\n        metrics_df = metrics_df.drop(columns=[\"metric_type\",\"scale_min\",\"scale_max\"])\n        metrics_df.to_csv(OUT / \"metrics_long.csv\", index=False, encoding=\"utf-8\")\n\n        # tiers_long.csv\n        tiers_df = combined[combined[\"metric_type\"]==\"tier\"].copy()\n        tiers_df = tiers_df.rename(columns={\"metric\":\"tier_kind\",\"value\":\"score\"})\n        tiers_df = tiers_df.drop(columns=[\"metric_type\",\"scale_min\",\"scale_max\"])\n        tiers_df.to_csv(OUT / \"tiers_long.csv\", index=False, encoding=\"utf-8\")\n\n    # assessment_summaries.csv\n    if summaries:\n        s_path = OUT / \"assessment_summaries.csv\"\n        s_df = pd.DataFrame(summaries)\n        prev_s = _safe_read_csv(s_path, [\"paper\",\"assessment_summary\"])\n        if not prev_s.empty:\n            prev_s = prev_s[~prev_s[\"paper\"].isin(newly_done[\"paper\"])]\n            s_df = pd.concat([prev_s, s_df], ignore_index=True)\n        s_df.to_csv(s_path, index=False, encoding=\"utf-8\")\n\n    idx.to_csv(IDX, index=False)\n    counts = idx[\"status\"].value_counts(dropna=False).to_dict()\n    print(\"Status counts:\", counts)\n    print(f\"Progress: {counts.get('completed',0)}/{len(idx)} completed\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data and methods</span>"
    ]
  },
  {
    "objectID": "methods.html#footnotes",
    "href": "methods.html#footnotes",
    "title": "Data and methods",
    "section": "",
    "text": "Occasionally they use 1 or 3 evaluators.↩︎\nSee their guidelines here; these criteria include “Overall assessment”, “Claims, strength and characterization of evidence”, “Methods: Justification, reasonableness, validity, robustness”, “Advancing knowledge and practice”, “Logic and communication”, “Open, collaborative, replicable science”, and “Relevance to global priorities, usefulness for practitioners”↩︎\n“a normative judgment about ‘how well the research should publish’” and “a prediction about where the research will be published”↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data and methods</span>"
    ]
  },
  {
    "objectID": "results.html",
    "href": "results.html",
    "title": "Results",
    "section": "",
    "text": "Include global setup and parameters\nsource(\"setup_params.R\")\n\n\n\n\nShow code\nlibrary(\"tidyverse\")\nlibrary(\"janitor\")\nlibrary(\"stringr\")\nlibrary(\"stringi\") #probably redundant?\nlibrary(\"lubridate\")\n#library(\"readr\") #redundant?\nlibrary(\"here\")\nlibrary(\"knitr\")\nlibrary(\"kableExtra\")    # For better table formatting\nlibrary(\"ggforce\")\nlibrary(\"ggrepel\")\nlibrary(\"glue\")\nlibrary(\"ggalluvial\")\nlibrary(\"scales\")\nlibrary(\"viridis\")       # For colorblind-friendly palettes\nlibrary(\"ggbreak\")\nlibrary(\"irr\")           # For Krippendorff's alpha\n\n\n\n\nShow code\nUJ_ORANGE &lt;- \"#f19e4b\"   # LLM\nUJ_GREEN  &lt;- \"#99bb66\"   # Human\n\ntheme_uj &lt;- function(base_size = 11) {\n  theme_minimal(base_size = base_size) +\n    theme(\n      panel.grid.minor = element_blank(),\n      plot.title.position = \"plot\",\n      legend.position = \"bottom\"\n    )\n}\n\n\n\n\nShow code\n# Canonical metric name mapping\ncanon_metric &lt;- function(x) dplyr::recode(\n  x,\n  \"advancing_knowledge\" = \"adv_knowledge\",\n  \"open_science\"        = \"open_sci\",\n  \"logic_communication\" = \"logic_comms\",\n  \"global_relevance\"    = \"gp_relevance\",\n  \"claims_evidence\"     = \"claims\",\n  .default = x\n)\n\nfix_bounds &lt;- function(df, lo, hi) {\n  lo2 &lt;- suppressWarnings(as.numeric(df[[lo]]))\n  hi2 &lt;- suppressWarnings(as.numeric(df[[hi]]))\n  swap &lt;- !is.na(lo2) & !is.na(hi2) & (lo2 &gt; hi2)\n  df[swap, c(lo, hi)] &lt;- df[swap, c(hi, lo)]\n  df\n}\n\nsafe_min &lt;- function(ci, pts) {\n  if (length(ci) == 0 || all(is.na(ci))) suppressWarnings(min(pts, na.rm = TRUE)) else suppressWarnings(min(ci, na.rm = TRUE))\n}\nsafe_max &lt;- function(ci, pts) {\n  if (length(ci) == 0 || all(is.na(ci))) suppressWarnings(max(pts, na.rm = TRUE)) else suppressWarnings(max(ci, na.rm = TRUE))\n}\n\n# Quantile/equal binning shared by both raters (for κ)\nbin_together &lt;- function(a, b, n_bins = 5, strategy = c(\"quantile\",\"equal\")) {\n  strategy &lt;- match.arg(strategy)\n  x &lt;- c(a, b)\n  x &lt;- x[is.finite(x)]\n  # discrete-ish fallback\n  if (length(unique(x)) &lt;= max(3, n_bins)) {\n    u &lt;- sort(unique(x))\n    f &lt;- function(v) match(v, u) - 1L\n    return(list(a_bin = f(a), b_bin = f(b), k = length(u)))\n  }\n  if (strategy == \"quantile\") {\n    qs &lt;- unique(quantile(x, probs = seq(0, 1, length.out = n_bins + 1), na.rm = TRUE))\n    if (length(qs) - 1L &lt; 2L) {\n      strategy &lt;- \"equal\"\n    } else {\n      edges &lt;- qs\n    }\n  }\n  if (strategy == \"equal\") {\n    lo &lt;- min(x, na.rm = TRUE); hi &lt;- max(x, na.rm = TRUE)\n    edges &lt;- seq(lo, hi, length.out = n_bins + 1)\n  }\n  # widen to include endpoints robustly\n  edges[1] &lt;- edges[1] - 1e-9\n  edges[length(edges)] &lt;- edges[length(edges)] + 1e-9\n  a_bin &lt;- cut(a, breaks = edges, include.lowest = TRUE, labels = FALSE) - 1L\n  b_bin &lt;- cut(b, breaks = edges, include.lowest = TRUE, labels = FALSE) - 1L\n  k &lt;- max(c(a_bin, b_bin), na.rm = TRUE) + 1L\n  list(a_bin = a_bin, b_bin = b_bin, k = k)\n}\n\n# Cohen κ (unweighted, linear, quadratic)  \n\nweighted_kappa &lt;- function(a_bin, b_bin, k = NULL, weights = c(\"quadratic\",\"linear\",\"unweighted\")) {\n  weights &lt;- match.arg(weights)\n  a &lt;- as.integer(a_bin); b &lt;- as.integer(b_bin)\n  keep &lt;- is.finite(a) & is.finite(b)\n  a &lt;- a[keep]; b &lt;- b[keep]\n  if (!length(a)) return(NA_real_)\n  if (is.null(k)) k &lt;- max(c(a,b)) + 1L\n\n  M &lt;- matrix(0, nrow = k, ncol = k)\n  for (i in seq_along(a)) M[a[i]+1L, b[i]+1L] &lt;- M[a[i]+1L, b[i]+1L] + 1\n  if (sum(M) == 0) return(NA_real_)\n  M &lt;- M / sum(M)\n  r &lt;- rowSums(M); csum &lt;- colSums(M)\n  E &lt;- r %*% t(csum)\n\n  I &lt;- matrix(rep(0:(k-1), times = k), nrow = k)\n  J &lt;- t(I)\n  if (weights == \"quadratic\") {\n    W &lt;- ((I - J)^2) / ((k - 1)^2)\n  } else if (weights == \"linear\") {\n    W &lt;- abs(I - J) / (k - 1)\n  } else {\n    W &lt;- 1 - diag(1, k)  # 1 off-diagonal, 0 on diagonal\n  }\n  num &lt;- sum(W * M); den &lt;- sum(W * E)\n  if (den == 0) NA_real_ else 1 - num/den\n}\n\n\n\nmetrics_meta &lt;- readr::read_csv(here(\"data\", \"metrics_meta.csv\"), show_col_types = FALSE) |&gt;\n  janitor::clean_names()\n\n# Model label from meta \nmodels_run   &lt;- metrics_meta |&gt;\n  dplyr::distinct(model) |&gt;\n  dplyr::pull(model) |&gt; na.omit()\ncurrentmodel &lt;- if (length(models_run) == 1) models_run else paste(models_run, collapse = \", \")\n\n# Token summary (input + output + reasoning tokens when available)\nmetrics_meta &lt;- metrics_meta |&gt;\n  dplyr::mutate(total_tokens = dplyr::coalesce(input_tokens, 0) +\n                                dplyr::coalesce(output_tokens, 0) +\n                                dplyr::coalesce(reasoning_tokens, 0))\n\ntok_sum &lt;- metrics_meta |&gt;\n  dplyr::summarise(\n    n_papers = dplyr::n_distinct(paper),\n    median_tokens = stats::median(total_tokens, na.rm = TRUE),\n    mean_tokens   = mean(total_tokens, na.rm = TRUE)\n  )\n\n\n\nreasoning_example = metrics_meta |&gt;\n  filter(!is.na(reasoning_summary), \n         paper == \"Williams et al. 2024\")\n\n\nHere we present preliminary results, starting with a comparison of the LLM‑generated quantitative ratings (model: gpt-5, see the(previous section) with human evaluations across the Unjournal’s criteria.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n–&gt;  –&gt;  –&gt;  –&gt;  –&gt;\n\n–&gt;  –&gt;  –&gt;  –&gt;\n\n–&gt;  –&gt;  –&gt;\n\n–&gt;  –&gt;  –&gt;\n\n–&gt;  –&gt;\n\n–&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;\n\n–&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;\n\n–&gt;  –&gt;  –&gt;  –&gt;\n\n–&gt;  –&gt;  –&gt;\n\n–&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;\n\n–&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;\n\n–&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;\n\n–&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;  –&gt;\n\n\n\n\n–&gt;  –&gt;\n\n–&gt;",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Results</span>"
    ]
  },
  {
    "objectID": "discussion.html",
    "href": "discussion.html",
    "title": "Discussion",
    "section": "",
    "text": "Limitations\nSample size and representativeness: We evaluated on only  ~40–50 papers, all in the social sciences and specifically chosen by The Unjournal for evaluation (which means they were considered high-impact or interesting). This is not a random sample of research literature. The papers also skew toward empirical and policy-relevant topics. The AI’s performance and alignment might differ in other fields (e.g., pure theory, biology) or on less polished papers.\nHuman agreement as a moving target: The Unjournal human evaluations themselves are not a single ground truth. As evidence of this, we note substantial variability between reviewers.\nPotential AI knowledge contamination: We attempted to prevent giving the AI any information about the human evaluations, but we cannot be 100% sure that the model’s training data didn’t include some fragment of these papers, related discussions, or even The Unournal evaluations. We will be able to exclude this for the evaluations of future Unjournal evaluations.\nModel limitations and “alignment” issues: While powerful, is not a domain expert with judgment honed by years of experience. It might be overly influenced by how a paper is written (fluency) or by irrelevant sections. It also tends to avoid extremely harsh language or low scores unless there is a clear reason, due to its alignment training to be helpful/polite – this could explain the general score inflation we observed. The model might fail to catch subtle methodological flaws that a field expert would notice, or conversely it might “hallucinate” a concern that isn’t actually a problem. Without ground truth about a paper’s actual quality, we used human consensus as a proxy; if the humans overlooked something, the AI could appear to “disagree” but possibly be pointing to a real issue.\n(There is also evidence, e.g. Pataranutaporn et al. (2025) that LLMs show biases towards more prestigious author names, institutions, and towards male prestigious authors. We will provide further evidence on this in the next iterations, de-identifying the work under LLM evaluation.)\nScoring calibration: The AI was prompted to use the 0–100 percentile scale, but calibrating that is hard. Humans likely had some calibration from guidelines or community norms (e.g. perhaps very few papers should get above 90). The AI might have been more liberal in using the high end of the scale (hence higher means). In future, a different prompt or examples could calibrate it to match the distribution of human scores more closely. We also only took one run from the AI for each paper; LLM outputs can have randomness, so a different run might vary slightly. (To do: aggregate across multiple runs.)\nSmall differences and rounding: Our analysis treated the AI’s numeric outputs at face value. Small differences (e.g. AI 85 vs human 82) might not be meaningful in practice – both indicate a similar qualitative assessment (“very good”). Some of our metrics (like kappa) penalize any difference, even if minor. Thus, the “low agreement” statistics might sound worse than the reality where in many cases AI and humans were only off by a few points. We intend to analyze the distribution of absolute differences: a large portion might be within say ±5 points which could be considered essentially agreement in practice. The credible intervals add another layer: sometimes an AI’s score fell outside a human’s interval, but overlapping intervals could still mean they agree within uncertainty. We did observe that AI’s intervals were often narrower than humans’ (LLM tended to be confident, giving ~10-point spreads, whereas some human evaluators gave 20-point or left some intervals blank), which is another aspect of calibration.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Discussion</span>"
    ]
  },
  {
    "objectID": "discussion.html#limitations",
    "href": "discussion.html#limitations",
    "title": "Discussion",
    "section": "",
    "text": "Planned updates and extensions\n\n\n\nAlso see internal tasks/issues in Coda\n\nRelated work\nSlides\nExtended evaluation:\n\nJournal ranking tiers and predictions\nClaim identification\nQualitative assessments and full evaluations\nComparing evaluations across fields/areas\n\nImproved workflow:\n\nImprove PDF ingestion\nSystem prompt optimization\nAlternative models\nExtend set of papers\n\nAggregating multiple LLM runs\nAnonymization\nEvaluation of papers for prospective (uncontaminated) evaluation\nMore grounded information theoretic metrics and robust statistical tests.\n\n\n\n\n\n\n\n\n\nPataranutaporn, Pat, Nattavudh Powdthavee, Chayapatr Achiwaranguprok, and Pattie Maes, “Can AI solve the peer review crisis? A large scale cross model experiment of LLMs’ performance and biases in evaluating over 1000 economics papers,” 2025.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Discussion</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Show code\nlibrary(\"grateful\")\n\ncitations &lt;- cite_packages(output = \"paragraph\",\n                           out.dir = \".\",\n                           cite.tidyverse = TRUE)\n\ncitations\n\n\nWe used R version 4.4.2 (R Core Team 2024) and the following R packages: ggalluvial v. 0.12.5 (Brunson 2020; Brunson and Read 2023), ggbreak v. 0.1.6 (Shuangbin Xu et al. 2021), ggforce v. 0.4.2 (Pedersen 2024), ggrepel v. 0.9.6 (Slowikowski 2024), glue v. 1.8.0 (Hester and Bryan 2024), here v. 1.0.1 (Müller 2020), irr v. 0.84.1 (Gamer, Lemon, and &lt;puspendra.pusp22@gmail.com&gt; 2019), janitor v. 2.2.0 (Firke 2023), kableExtra v. 1.4.0 (Zhu 2024), knitr v. 1.49 (Xie 2014, 2015, 2024), rmarkdown v. 2.29 (Xie, Allaire, and Grolemund 2018; Xie, Dervieux, and Riederer 2020; Allaire et al. 2024), scales v. 1.3.0 (Wickham, Pedersen, and Seidel 2023), stringi v. 1.8.4 (Gagolewski 2022), tidyverse v. 2.0.0 (Wickham et al. 2019), viridis v. 0.6.5 (Garnier et al. 2024).\n\n\n\n\nAczel, Balazs, Barnabas Szaszi, and Alex O Holcombe, “A\nbillion-dollar donation: Estimating the cost of researchers’ time spent\non peer review,” Research integrity and peer review, 6\n(2021), 1–8 (Springer).\n\n\nAllaire, JJ, Yihui Xie, Christophe Dervieux, Jonathan McPherson, Javier\nLuraschi, Kevin Ushey, Aron Atkins, Hadley Wickham, Joe Cheng, Winston\nChang, and Richard Iannone, “rmarkdown: Dynamic documents for r,”\n(2024).\n\n\nBrunson, Jason Cory, “ggalluvial: Layered grammar for alluvial\nplots,” Journal of Open Source Software, 5 (2020),\n2017.\n\n\nBrunson, Jason Cory, and Quentin D. Read, “ggalluvial: Alluvial plots in ‘ggplot2’,” 2023.\n\n\nEger, Steffen, Yong Cao, Jennifer D’Souza, Andreas Geiger, Christian\nGreisinger, Stephanie Gross, Yufang Hou, Brigitte Krenn, Anne Lauscher,\nYizhi Li, Chenghua Lin, Nafise Sadat Moosavi, Wei Zhao, and Tristan\nMiller, “Transforming\nscience with large language models: A survey on AI-assisted scientific\ndiscovery, experimentation, content generation, and\nevaluation,” arXiv preprint arXiv:2505.05151,\n(2025).\n\n\nFirke, Sam, “janitor: Simple tools for examining and cleaning\ndirty data,” (2023).\n\n\nGagolewski, Marek, “stringi: Fast and portable character\nstring processing in R,” Journal of\nStatistical Software, 103 (2022), 1–59.\n\n\nGamer, Matthias, Jim Lemon, and Ian Fellows Puspendra Singh\n&lt;puspendra.pusp22@gmail.com&gt;, “irr: Various coefficients of interrater\nreliability and agreement,” (2019).\n\n\nGarnier, Simon, Ross, Noam, Rudis, Robert, Camargo, Antônio Pedro,\nSciaini, Marco, Scherer, and Cédric, “viridis(Lite) - colorblind-friendly color maps for\nr,” (2024).\n\n\nHester, Jim, and Jennifer Bryan, “glue: Interpreted string literals,”\n(2024).\n\n\nLuo, Ziming, Zonglin Yang, Zexin Xu, Wei Yang, and Xinya Du, “LLM4SR: A survey on large\nlanguage models for scientific research,” arXiv preprint\narXiv:2501.04306, (2025).\n\n\nMüller, Kirill, “here: A simpler way to find your\nfiles,” (2020).\n\n\nPataranutaporn, Pat, Nattavudh Powdthavee, Chayapatr Achiwaranguprok,\nand Pattie Maes, “Can AI solve\nthe peer review crisis? A large scale cross model experiment of LLMs’\nperformance and biases in evaluating over 1000 economics\npapers,” 2025.\n\n\nPedersen, Thomas Lin, “ggforce: Accelerating ‘ggplot2’,” (2024).\n\n\nR Core Team, “R:\nA language and environment for statistical computing,”\n(Vienna, Austria, R Foundation for Statistical Computing, 2024).\n\n\nShuangbin Xu, Meijun Chen, Tingze Feng, Li Zhan, Lang Zhou, and\nGuangchuang Yu, “Use ggbreak to\neffectively utilize plotting space to deal with large datasets and\noutliers.” Frontiers in Genetics, 12 (2021), 774846.\n\n\nSlowikowski, Kamil, “ggrepel: Automatically position non-overlapping\ntext labels with ‘ggplot2’,” (2024).\n\n\nWickham, Hadley, Mara Averick, Jennifer Bryan, Winston Chang, Lucy\nD’Agostino McGowan, Romain François, Garrett Grolemund, Alex Hayes,\nLionel Henry, Jim Hester, Max Kuhn, Thomas Lin Pedersen, Evan Miller,\nStephan Milton Bache, Kirill Müller, Jeroen Ooms, David Robinson, Dana\nPaige Seidel, Vitalie Spinu, Kohske Takahashi, Davis Vaughan, Claus\nWilke, Kara Woo, and Hiroaki Yutani, “Welcome to the tidyverse,” Journal of Open Source\nSoftware, 4 (2019), 1686.\n\n\nWickham, Hadley, Thomas Lin Pedersen, and Dana Seidel, “scales: Scale functions for\nvisualization,” (2023).\n\n\nXie, Yihui, “knitr: A comprehensive\ntool for reproducible research in R,” in\nImplementing reproducible computational research, Victoria\nStodden, Friedrich Leisch, and Roger D. Peng, eds. (Chapman; Hall/CRC,\n2014).\n\n\n——, “Dynamic documents with\nR and knitr,” (Boca Raton, Florida, Chapman;\nHall/CRC, 2015).\n\n\n——, “knitr: A general-purpose package for dynamic\nreport generation in r,” (2024).\n\n\nXie, Yihui, J. J. Allaire, and Garrett Grolemund, “R markdown: The definitive\nguide,” (Boca Raton, Florida, Chapman; Hall/CRC, 2018).\n\n\nXie, Yihui, Christophe Dervieux, and Emily Riederer, “R markdown\ncookbook,” (Boca Raton, Florida, Chapman; Hall/CRC, 2020).\n\n\nZhang, Tianmai M, and Neil F Abernethy, “Reviewing scientific papers\nfor critical problems with reasoning LLMs: Baseline approaches and\nautomatic evaluation,” arXiv preprint\narXiv:2505.23824, (2025).\n\n\nZhang, Yaohui, Haijing Zhang, Wenlong Ji, Tianyu Hua, Nick Haber,\nHancheng Cao, and Weixin Liang, “From replication to redesign:\nExploring pairwise comparisons for LLM-based peer review,”\narXiv preprint arXiv:2506.11343, (2025).\n\n\nZhu, Hao, “kableExtra: Construct complex table with\n‘kable’ and pipe\nsyntax,” (2024).",
    "crumbs": [
      "References"
    ]
  }
]